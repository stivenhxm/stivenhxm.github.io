08｜数据库设计：怎样按领域模型设计数据库？
你好，我是钟敬。
这节课，我们来学习数据库设计。
前面我们说过，模型驱动设计可以分成两大部分：模型的建立和模型的实现。模型的建立要求模型和业务需求一致，模型的实现要求实现和模型一致。现在，咱们已经建立了领域模型，并且从理论层面对模型驱动设计的概念进行了总结，这些都属于模型的建立。而我们这节课要做的数据库设计，则属于模型的实现。
那么，怎样由领域模型，一步一步地推导出数据库的设计呢？这种方法和以前的方法有什么不同呢？这节课我们就来讨论这两个问题。在这个过程中，我们要着重体会数据库设计是如何与领域模型保持一致的。
今天讲的内容，在软件工程中叫做建立物理数据模型（physical data model, PDM），主要目的就是对数据表进行设计。具体来说，包括以下几点：
建立哪些表；
表中有哪些字段；
表的主键和外键是什么；
字段的数据类型以及约束。
还有一点要说明，虽然我们的例子是用 MySQL 完成的，但我们讲的是通用原理，所以采用其他数据库引擎的话，道理也是一样的。
我们在领域建模的时候把模型分成了四个模块，下面，我们就一个模块一个模块地进行数据库设计。

“租户管理”的数据库设计
咱们就从最简单的租户管理模块开始吧，下面是这个模块的模型图：

一般来说，一个实体可以映射为一个数据库表。所以，咱们可以先根据租户实体设计出租户表。可以用下面的符号表示：

前面说过，今天的内容，是建立物理数据模型。和 UML 不同，物理数据模型的图示法并没有统一的国际标准。所以不同的专家、不同的工具，画出来的都不太一样。这里我用了绘图工具（draw.io）中提供的符号。
另外，还可以用建表语句（create table） 表示表的结构。建表语句和图形符号是同一个意思的两种等价的表示方法，比如上图可以直接翻译成下面的建表语句：
CREATE TABLE tenant (
   id INT PRIMARY KEY
);
所以，原则上直接用建表语句进行数据库设计也是可以的。不过为了直观，我们的课程中还是用图示的方法。
下面我们仔细看看表示数据表的符号。
首先看这个符号的第一行，这里的 tenant 是表的名称。在领域建模阶段，为了和领域专家进行沟通，模型中使用的都是中文。但建表时，一般要用英文来命名。那问题就来了，怎么保证中英文的一致，从而在实现层面贯彻统一语言呢？
答案就是使用我们前面建的词汇表。在词汇表里，我们规定了每个中文词汇对应的英文全称和简称。在为数据库表以及字段等命名时，如果词汇表中有简称就用简称，否则就用全称。我们把词汇表在这里再列一遍作为参考。

在词汇表里，查到租户的英文是 tenant，所以用它作为表的名称。
然后我们再看这个表符号的第二行，这是表的主键，包括主键的名称 “id” 和数据类型 “int” 。“PK”（primary key）表示这个字段是一个主键。
除了这种命名法以外，主键命名的另一种常见做法是包含表名，也就是命名为 tenant_id。不过我比较习惯极简主义，所以只用了 id。两种方法都可以，根据你具体项目的规定来选择就行了。
最后，我们再为这个表添加其他字段。领域模型中的属性，一般会映射成表中的字段。
在领域建模的时候，为了模型的简洁和稳定，我们主张只写出有助于表达实体含义的主要属性，一些不言自明的属性就不用写了。但在数据库设计阶段，就要根据需求列出所有字段了。这里，我们要补充下面几个字段：

name 表示租户的名称。created_at，created_by，last_updated_at 和 last_updated_by 分别表示一条记录的创建时间、创建人、最后一次修改时间和最后一次修改人。创建人和最后修改人保存的是用户的 id。
这四个字段常常被称为审计字段，可以用来进行安全审计和错误排查。作为一种最佳实践，我们在每一个表中都会包含这四个字段。
“组织管理”的数据库设计
做好了租户管理，我们继续为组织管理进行数据库设计。领域模型如下：

首先，我们用类似的方法为组织实体建表，如下图：

先看图中的实线箭头，这个箭头代表外键参照关系。按照领域模型，租户和组织是一对多关联。一个一对多关联，在数据库设计时可以映射成一个外键。
图中的 FK（foreign key) 代表外键。FK = tenant_id 说明 org 表中指向 tenant 表的外键是 tenant_id 字段。
此外，我们还添加了非空（NOT NULL）约束。这和领域模型中的多重性有关。租户和组织间的关联，在租户端实际是“1..1”，也就是说一个组织至少会关联一个租户，最多也只能关联一个租户。“1..1”前面的“1”就映射成了组织表里 tenant_id 字段后面的非空约束。假如不是“1..1”而是“0..1”，那么就不会有 NOT NULL 了。所以，关联上的多重性决定了外键字段的非空约束。
不过，在基于云的应用里，为了减少数据库处理的瓶颈，一般不主张建立真正的外键，而是用程序来保证外键约束。但是在物理数据模型里，我们又希望表达外键参照，方便理解数据表间的关系。这时候，我们可以把实线箭头换成虚线箭头，表示虚拟外键，如下图：

后面我们所有的数据表设计都采用虚拟外键。
事实上，数据库中其他所有表都有一个指向 tenant 表的虚拟外键，以便区分是哪个租户的数据。如果每个虚拟外键都画出来，我们的图会变得很乱，所以后面就只在表中写出 tenant_id，不画箭头了，我们可以用一个注释说明这件事。

接下来，咱们用类似的方法完成组织、组织类别和员工实体。如下图：

我们为这张图补充几点说明。
首先看 org（组织）表，这里有一个指向自身的虚拟外键 superior_id ，表示组织之间的上级关系，对应于领域模型中的自关联。
然后还可以看到 emp（员工）表和 org 表之间有两个方向相反的虚拟外键，一个表示组织的负责人关系，另一个表示员工归属于哪个组织。
另外，emp 表中的 num、id_num、name、gender、dob 分别表示员工号、身份证号、姓名、性别和出生日期（date of birth）。
最后，我们来处理岗位。

你可能注意到了，岗位和员工之间是多对多关联。这时，我们必须增加一个关联表，来表达两者之间的关系，如下图：

这里，我们增加了 emp_post 表来表达多对多的关联。表中包含了 post (岗位) 和 emp 两个表的主键作为自己的虚拟外键。我们采用了由 emp_id 和 post_id 两个字段组成的复合主键，因为这时添加一个单独的 id 主键并没有什么意义。
一般来说，我们都主张用单独的 id 主键，只有符合以下两个条件时，才应该使用上面这种联合主键：
第一，两个外键字段，例如 emp_id 和 post_id ，唯一决定了一条记录；
第二，这个表的主键没有被其他表作为外键引用。
“项目管理”数据库设计
好，现在我们完成了组织管理模块的数据库设计，接着做项目管理模块。在下面这张领域模型图中，我省略了和项目管理无关的部分。

用前面的方法，我们可以画出项目管理模块的物理数据模型图：

在这张图里，有没有注意到员工表的名称写成了 emp: 2 ，而且除了主键以外没有其他属性？
这其实是一种绘图技巧。为了避免整张图像蜘蛛网一样凌乱，我们不打算把所有表都画在同一张图上，而是每个模块画一张。而 emp 表在组织管理中出现过一次，在项目管理中又出现了，所以我们用了 emp: 2 说明这是 emp 表的第 “2” 次出现。
至于属性，我们只在 emp 表第一次出现的时候详细写出来就可以了，其他地方不写属性，这样，当需要更改属性的时候，只改一个地方就可以了。
“工时管理”的数据库设计
完成了项目管理模块，我们来设计最后的工时管理模块。领域模型图如下：

用我们前面的知识，很容易就能做出下面的设计：

到这里，数据库设计就完成了。那么让我们再思考一下，这种基于领域模型的方法和我们以前常用的做法有什么区别呢？
按照 DDD 进行数据库设计和“以前方法”的对比
要回答这个问题，我们先来明确一下这里所谓以前的方法指什么。传统的软件工程中本来就有一套以 ER 图为工具、规范的数据库设计方法。不过我们多数小伙伴并没有严格按照这种方法去做，而是直接拍脑袋设计数据表。我们可以把这两种方法称为“ER 图法”和“拍脑袋法”，看看它们和我们这节课的方法有什么区别。
与“拍脑袋法”的区别
先看看和“拍脑袋法”的区别。如果我们只是靠直觉设计数据库，不去深入分析领域知识，虽然刚开始时可能可以满足业务需求，但随着需求越来越复杂，问题就会逐渐浮现出来。
首先我们要知道，无论是数据模型图还是建表语句，都是面向技术人员的，业务专家很难理解。所以我们无法使用这些方式和业务专家沟通，也就很难保证数据库设计能准确地反映领域知识。而按照 DDD 的方法，我们可以先基于领域模型和业务专家对齐需求，再把领域模型转换为数据库设计，从而解决领域知识的沟通问题。
第二个问题在于，这样随意的数据库设计，很可能会违反数据库设计的范式，造成数据冗余和潜在错误。范式（NF）是规范形式（Normal Form）的简称，核心思想在于避免数据的冗余。也就是说，数据表的范式越高，数据冗余就越少。
不过在实践中，一般做到第三范式就够了。范式并不是用于直接进行数据库设计的，而是正确的数据库设计的反向验证。正确地运用领域模型进行数据库设计，一般而言，就不会违反第三范式了。
与“ER 图法”的区别
接着再看看我们的方法与“ER 图法”的区别。
传统的软件工程，是按照“概念设计”“逻辑设计”和“物理设计”的步骤进行数据库设计的。其中概念设计和逻辑设计，通常会采用 ER 图，也就是实体联系图。ER 图同样没有业界统一的标准，有多种画法。下面这张图用了一种常用的画法，表示组织和员工的一对多关系。

这里要注意一点，有些人以为前面的物理数据模型图就是 ER 图，其实是不对的。ER 图的关注点和领域模型图类似，是实体以及实体之间的关联关系，而物理数据模型图关注的是表、字段、主键和外键等等。
那 ER 图法和我们这节课讲的方法有什么区别呢？
首先，采用 UML 类图描述的领域模型图是 ER 图的超集。也就是说，ER 图能表达的，领域模型图都能表达；而领域模型图能表达的，ER 图未必能表达。因此，使用领域模型图以后，我们就不必再使用 ER 图了。
其实我们前几节课进行的领域建模，大体上相当于传统意义上的“概念设计”。如果把领域模型中的属性都补全，就相当于传统意义的“逻辑设计”了。而我们今天做的，其实就是传统上的“物理设计”，所以产物叫做“物理数据模型”。
第二个区别是，ER 图只能表达静态的数据关系，只用于数据库设计，而领域模型图则可以将静态数据和动态行为绑定，不仅可以用于数据库设计，还可以用于程序设计，这一点我们在后面的课程会看到。也就是说，基于 DDD 的方法能够保证程序设计和数据库设计的高度统一。
第三个区别是，领域模型对应的主要是传统软件工程的分析模型，而 ER 图在传统软件工程里则处于设计阶段，所以两者的层次和使用场合也是不一样的。
总结
好，这节课的主要内容就讲完了，我们来总结一下。
DDD 主张要根据领域模型来进行数据库设计，保证数据库和领域模型的一致，从而保证数据库和业务需求以及代码的一致性。在进行数据库设计时，我们可以用物理数据模型图，也可以直接用建表语句，两者基本是等价的。为了直观，我们采用了图示的方法。
对数据表、字段等等的命名，应该依据词汇表，以便保证统一语言。一般来说，领域模型中的实体映射为数据库中的表；领域模型中的属性，映射成表中的字段。同时还要根据需求补充更多的字段。
模型中的一个一对多关联，可以映射成一个外键字段，以及一个外键约束。但基于云的应用一般不会真的建立外键约束，而外键的逻辑关系还是存在的。我们用虚线箭头表示这种逻辑上的外键关系，称为虚拟外键。对于多对多关联，我们必须增加一个关联表，其中包括了两个实体表各自的主键。另外，关联上的多重性决定了外键字段的非空约束。
最后，我们还总结了基于 DDD 的数据库设计和以前方法的区别。比起“拍脑袋”的方法，DDD 的方法更容易和业务专家对齐领域知识，而且不容易违反数据库设计范式。另一方面，DDD 方法是 ER 图法的“超集”，并且能够将静态数据和动态逻辑整合在一起，达到业务、数据库和代码三者的统一。
思考题
最后有两个思考题：
1. 我们在多数数据表设计中都用了没有业务含义的 id 作为主键，这种做法比起使用有业务含义的字段做主键有什么优点？
2. 我们今天讲的数据表设计都是符合第三范式的，但有时为了性能的原因，常常会有意引入冗余字段，进行“反规范化”设计。在反规范化设计中，你觉得应该注意什么呢？
好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们讲解 DDD 代码的分层架构，开始进入编程阶段。





09｜分层架构：怎样逃离“大泥球”？
钟敬 2022-12-24

你好，我是钟敬。
上节课，我们完成了数据库设计，解决的是怎样保证数据库和领域模型一致的问题。接下来，我们来解决怎样保证代码与模型一致的问题。
这个问题又分成两个层面。第一个层面是要有一个合理的代码架构，第二个层面是更详细的代码编写。今天我们主要解决第一个层面的问题，通过引入 DDD 的分层架构，建立代码的骨架。
我们这节课的方法综合了《领域驱动设计：软件核心复杂性应对之道》（后面简称《DDD》）这本书里的内容以及“六边形架构”的思想。六边形架构是由敏捷软件开发专家 Cockbun 提出的，用来分离技术和非技术关注点。如果你只是想掌握分层架构的最佳实践，那么学习这门课就可以了；如果还想进一步了解六边形架构的来龙去脉，可以读一下作者本人的文章。
那么，我们为什么要采用分层架构呢？原因就是为了避免“大泥球”式的代码。
源代码仓库地址
课程迭代一的配套代码，可以点这里获取。
逃离“大泥球”
我们知道，系统中的代码都有各自的目的，有些处理领域逻辑，有些处理用户界面，有些处理数据库的访问……这些代码的关注点各不相同。但在很多开发团队中，并没有明确的手段来分离代码的关注点，从而使不同关注点的代码混在一起，这样就会造成下面几个问题。
首先，很难单独识别出反映领域逻辑的代码，从而难以保证与领域模型的一致性。
其次，应该内聚的逻辑分散在不同地方，应该解耦的逻辑又混在一起，造成代码难以理解。
再次，修改业务代码，可能会影响技术代码，修改技术代码，又可能会影响业务代码，造成代码很难维护。
最后，经过一段时间的维护，代码变得日益混乱，代码中出现大量重复和不一致，经常出现质量问题。
这种难以维护，毫无规范的代码就被称为“大泥球”（big ball of mud），我们用这张图来表示：

而分层架构就是解决大泥球问题的一种最佳实践，可以有两种等价的画法，一种由内而外，另一种自下而上，如下所示：

不过，目前业界用左边这种圈层结构的比较多，所以我们在课程中也采用这种画法。
从图上面可以看到，分层架构把代码分成若干层，每层负责不同的关注点。图里的箭头表示依赖关系，这里的意思是只能外层依赖内层，内层不能依赖外层。
这背后其实是根据软件架构中的一个重要原则：代码中不稳定的部分，应该依赖稳定的部分。所以，分层架构中越是内层，就越稳定，越是外层，相对就越容易变化。
那么问题就来了，我们具体要怎么划分代码的层次呢？这就是我们这节课的重点。下面我们来具体学习每个层次。
分离领域
首先，DDD 对代码架构最核心的要求就是要将领域层分离出来。领域层封装了领域数据和逻辑，我们前面的领域模型所对应的代码，主要就体现在领域层。只有将领域层独立出来，才能保证与领域模型的一致，也才能让领域层独立演化。下面是分离领域层后的示意图：

在代码层面，一个层对应于一个 Java 包或者 C# 的命名空间，一般命名为 domain。在 domain 包里，我们要根据领域模型中的模块进一步分包。这样，就保证了在模块一级代码和模型的一致性。下面这张图包含了领域层和模块的程序结构：

图中的 Unjuanable 是项目的根，这是咱们自造的单词，就是“不要卷了”（un-juan-able）的意思，这是开个玩笑。而 Effortmng、orgmng、projectmng 和 tenantmng 就是领域模型中的四个模块，命名还是依据之前建立的词汇表。
这里再强调一句，分离领域是 DDD 的基本要求。当然对于简单应用，也可以不分离领域，但这时就不能宣称自己是按照 DDD 来编码了。
尽管领域层也会随着需求不断演化，但对于一会儿要介绍的其他层而言，这一层仍然是相对稳定的。所以，领域层处于我们架构的最内层，是整个系统的核心，这也符合 DDD 的基本理念。
按模块分包以后，我们接着按照领域模型，在模块包中建立实体类，这样就能在类的层面和模型保持一致了。这里先为每个类写一个“空壳”，至于怎么编写类的属性、关联、逻辑等，我们在后面的课程再介绍。下图是增加了实体类的代码结构，命名仍然是依据词汇表，后面就不重复说了：

给领域一个“门面”
那么，领域层封装的逻辑通常是细粒度的，并不适合直接作为 API 暴露给外部。另外，还有一些不属于领域层的横切关注点，比如像事务控制，应该单独处理。所以，我们往往要在领域层外面再加一层，DDD 和六边形架构都将这一层称为 Application，也就是应用层。如下图所示：

这一层主要负责下面这些逻辑：
1. 接受来自客户端的请求，调用和协调领域层的逻辑来解决问题；
2. 将领域层的处理结果封装为更简单的粗粒度对象，作为对外 API 的参数。这里说的粗粒度对象一般是 DTO（Data Transfer Object），也就是没有逻辑的数据传输对象，应用层负责 DTO 和领域对象的数据转换；
3. 负责处理事务、日志、权限等等横切关注点。从设计模式的角度，这一层相当于“门面”（Facade）模式，如果你想更深入地了解这个模式，可以读一下相关书籍，例如 《Head First 设计模式》。
应用层本身并不包含领域逻辑，而是对领域层中的逻辑进行封装和编排。我们不妨把应用层的逻辑称为应用逻辑。应用逻辑和领域逻辑的区别有时比较微妙，在后面的课程里我们还会再举例说明。
封装应用逻辑的类通常没有状态，只有方法，一般称为应用服务，我们可以用 XxxService 的形式来命名。下面就是增加了一些主要应用服务的代码结构：

用“适配器”处理输入输出
除了业务功能之外，程序里还有另一个重要的关注点——输入输出技术。我们的系统要和外界打交道，可以通过不同技术来实现，比如 Restful API、 RPC，以及传统的 Web 页面等等。对于同一个业务功能，可能过去使用 Restful API ，现在由于技术变革，需要改为 RPC。但不论具体技术是哪一种，背后实现的业务功能很可能都是一样的。所以，输入输出技术和业务功能是两个不同的关注点。
为了分离这两个关注点，我们在应用层外面再加一层，专门处理输入输出技术，如下图所示：

六边形架构中将这层称为适配器，英文是 adapter。这是因为，这一层的目的是把业务功能“适配”到不同的输入输出技术。
适配器会把和具体技术有关的请求，翻译成和技术无关的请求，再调用应用层来实现业务功能；在接收到应用层的返回值以后，又转化成技术相关的响应，返回给外界。也就是说适配器层屏蔽了输入输出技术的差异，从而使应用层与具体技术无关，这样就达到了分离关注点的目的。
下图是增加了适配器层的代码结构：

如果我们的系统要处理多种输入输出技术，那么适配器层可以按照具体技术来分包。比如在上面的代码例子里， Restful 包里是 Resful Api，web 包里面是传统的 JSP 页面。这些包里的适配器，在多数情况下，就是我们熟悉的 Controller。不过，我们并不打算在这个项目里真的使用 JSP，这里的 web 只是为了举例。
用“适配器”处理数据持久化
最后，我们还要处理一个关注点，就是数据的持久化。在传统上，数据持久化就是访问数据库。但是现在，对缓存、文件系统、对象存储服务等等的访问，一般也算作数据的持久化。
不过，在引入新的分层之前，我们先讲 DDD 里的另一个模式，叫做 Repository，中文可以叫仓库。这个模式用于封装持久化的代码，大体上类似于传统上说的 DAO（Data Access Object），也就是“数据访问对象”。
但和 DAO 不同的是，仓库是以聚合为单位的，每个聚合有一个仓库，而 DAO 是以表为单位的，每个表有一个 DAO。我们在第二个迭代才会正式介绍聚合，现在咱们姑且认为，一个实体就对应一个仓库。
那么，仓库和适配器有什么关系呢？
其实，数据库访问也是和具体技术相关的。同样的数据，可以存到 Oracle，也可以存到 MySQL；既可以用 MyBatis 访问，也可以用 JPA 访问。这些都是具体的技术，和前面一样，我们需要一种适配器把具体的持久化技术和应用层以及领域层隔离开，而仓库就充当了这种适配器。
但是仔细想一下，你可能会发现，仓库和前面的 Controller 虽然都是适配器，但有一个重要的区别。Controller 处理的是从外界向系统的调用，比如说来自 HTTP 客户端的调用；而仓库处理的是由系统向外界的调用，比如说对数据库的调用。也就是说，两者的方向不同。
在六边形架构里，把由外向内的适配器叫做 driving adapter，我把它译作主动适配器；而由内向外的适配器叫做 driven adapter，可以译作被动适配器。准确地说，被动适配器的作用不限于访问数据库，而是访问所有外部资源。
现在，我们可以把原来的适配器层分成两个部分，像下面这样。

这两种适配器都处于同一层，但由于性质不同，因此又可以分成两个子层。相应的代码结构是下面这样：

我们可以看到，adaper 包被分成了 driving 和 driven 两个子包，分别代表两种适配器。在 driving 里还是上一节说的 Controller，而 driven 包下的内容则是新加的。Persistence 是“持久化”的意思，这个包里面就是用于持久化的各个仓库。
存放通用工具和框架
到现在为止，我们已经讲了 DDD 分层架构中最主要的几层，但还有另外一些代码没有考虑。比如说，我们写了一些用于字符串和日期处理的工具类，这些工具可能被上面说的任何一层调用。又比如说，我们可能对 Spring 框架进行薄薄的一层封装，以便更适合自己的产品使用，甚至可以写一些自己的小框架，这些框架性的代码也可能用于上面说的任何一层。
既然这些代码可能被前面的所有层依赖，那么是不是说，这些代码应该处于整个系统的最内层呢？如果这样做，那么和 DDD 所强调的以领域层为核心的思想就矛盾了。但如果不这么做，是不是又违反了层间依赖原则呢？
事实上，我们可以认为这些代码和前面说的各层根本不在同一个维度，它们是对各层代码起到公共的支撑作用的。用下面这张图比较容易说明这个思路。

你看，我们前面讲过的领域层、应用层和适配器层处于同一个平面，而公共支撑部分在另一个平面，对上面的平面进行支撑。这一层倒是没有什么统一的名字，不过业界很多人喜欢把它叫做 common。下面就是增加了 common 层的代码结构：

这里，我们增加了一个 common 包，下面又有两个子包。其中 framework 存放框架性的代码，而 util 存放工具性的代码。框架和工具的区别一般是，框架会调用我们自己写的代码，而工具则被我们写的代码所调用。
分层架构的权衡
那么，学完前面所有的内容，你可能会问：“我在自己的项目里一定要按这里方法分层吗？不这样分层就不是 DDD 了吗？”
其实，这节课的目的并不是让你在实际项目里照搬这里的架构，而是希望你能够理解分层架构背后的原理，然后针对自己项目中存在的痛点进行权衡，形成适合自己项目的架构规范。
在实际项目中，根据具体情况，有些层次可以合并，而有些层次则可以分得再细一些。在下面的表里，我列出了几种分层架构的变化，供你参考。

总结
好，今天的主要内容就讲完了，下面来总结一下。
这节课，我们首先解释了分层架构的目的，也就是通过关注点分离，保证代码和领域模型的一致性，并避免大泥球式的代码，提高程序的可维护性。分层架构要求只能外层依赖内层，不能内层依赖外层。
然后，我们再结合《DDD》一书以及六边形架构，在代码里引入了各个层次：
领域层，用来封装领域数据和逻辑。这一层与领域模型直接对应，是整个系统的核心。
应用层，作为领域层的“门面”，把领域层封装成更粗粒度的服务供外部使用，并且处理事务、日志等横切关注点。
主动适配器，用来接收来自外部的请求。屏蔽具体的输入输出技术。
被动适配器，用来访问外部资源。被动适配器和主动适配器都属于适配器层，区别在于调用的方向不同。适配器层与具体输入输出和资源访问技术有关，而应用层和领域层与具体技术无关。这样我们就分离了技术和业务的关注点。
最后，我们引入了 common 层，用于存放工具和框架。这一层对前面的各层进行支撑。
正如前面所说的，这节课的目的不是为了让你完全照搬这里的架构，而是希望你能够通过这节课的学习，理解背后的原理，并在实践中进行权衡，找到适合自己项目的架构。
思考题
最后是两道思考题：
1. 在适配器中，我们举了 Restful API、RPC、Web、Repository 几种最常见的情况，根据你的经验，还有哪些其他种类的适配器？
2. 分层架构规定只能外层依赖内层，在今天讲的几层中，有一处可能会破坏这种层间依赖关系，你能找出来吗，有没有解决办法？
好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们来一起编写具体的代码逻辑。




10｜代码实现（上）：要“贫血”还是要“充血”？
钟敬 2022-12-27



1.0x

讲述：钟敬大小：16.08M时长：17:36
你好，我是钟敬。
上节课我们根据 DDD 的分层架构，建立了程序的“骨架”，今天开始，我们来编写具体的逻辑，给骨架上“添肉”。其实仅仅从完成功能的角度来说，这些程序你也会写，但关键是怎么按照 DDD 的要求来写。
按照 DDD 的要求，我们首先要考虑的问题是，怎么使代码和模型保持一致？这还可以细化成几个子问题，比如怎么实现业务规则、怎么表示对象间的关联、怎么区分领域逻辑和应用逻辑等等。
其次，我们还要考虑一些通用的编程问题，比如说是采用贫血模型还是充血模型、怎么减少重复、怎样实现模块化，等等。
所以接下来三节课，咱们先选取几个比较简单的功能，用不太完善的方法把程序写出来，再一步一步地重构，达到我们希望的样子。在这个过程中，我们也会学到 DDD 在实现层面的几个模式。
今天，我们会首先讨论面向对象和面向过程间的权衡，然后在代码层面重点解决层间依赖问题。
开始之前要先说明一下，下面例子中的代码是用 Java 和 Spring 来写的，不过我们的重点是普遍原理而不是语言和框架的细节，所以对于其他语言来说，道理也是一样的。
“面向对象”还是“面向过程”？
提到编码，我们常常说起的一个问题就是：应该采用贫血模型还是充血模型？
一些人主张，DDD 应该采用充血模型， 但是实践中，多数小伙伴，虽然也觉得充血模型更高大上一点，但用的还是贫血模型。今天咱们就先掰扯一下这个话题。
贫血模型，英文叫做 Anemic Domain Model ，是 Martin Fowler 在 2003 年提出的，恰好在《DDD》这本书写作的同一年。贫血模型指的是领域对象中只有数据，没有行为，由于过于单薄，就好像人贫血了一样，显得不太健康。这种风格违背了面向对象的原则。
所以，Martin Fowler 认为这是一种反模式，他主张的方式叫做 Rich Domain Model，可以译作“富领域模型”，也就是领域对象里既包含数据，也包含行为。
至于所谓充血模型则是后人提出的，这个人还把模型分成四种：失血模型、贫血模型、充血模型和胀血模型。问题在于他说的贫血模型和 Matin Fowler 说的又不一样，而“充血模型”和“富领域模型”也不是一回事，这就造成了今天业界术语的混乱。
所以，为了避免混淆，我不采用“充血模型”这个词。在后面的讨论中，我会把贫血模型称为面向过程或者过程式编程，把富领域模型称为面向对象或对象式编程，因为真正的面向对象本来就是包含丰富逻辑的。
那么问题来了，如果面向对象真的明显好于面向过程，为什么多数人还在用面向过程呢？除了咱们程序员自己学艺不精以外，有没有什么合理性呢？
其实，早期的面向对象编程，主要是用来开发桌面软件的，比如说开发一个 Office、一个 IDE 等等。这类软件的特点是基本上整个软件的数据都能装入内存，这样就可以通过对象之间自由的导航实现复杂的逻辑。对象在内存里形成一种网状结构，称为对象图（Object Graph）。
但是企业应用则有一个本质的不同，就是数据主要在数据库里，每次只能把一小部分远程拿到内存，所以不能在内存里对对象进行自由地导航。这个区别就造成，早期的面向对象编程很难直接用在企业应用，间接导致了贫血模型的普及。尽管用 JPA 之类的 ORM 框架可以减少这种痛苦，但底层原因并没有消除，所以 ORM 框架在解决一些问题的同时，又带来了另外一些的问题。
早年，很多像 Martin Fowler 这样的专家认为面向对象就是王道，我把他们称为面向对象的“原教旨主义者”。但是到了今天，包括 Martin Fowler 在内的很多人已经成长为编程范式的“中立主义者”，也就是并不局限于面向对象，而是将面向对象、面向过程、面向方面、函数式等等编程范式结合起来。这也是咱们的课程所遵循的思想。
实际上，面向对象和面向过程并不是非黑即白的关系，而是像下面这张图这样：

在纯粹的面向对象和纯粹的面向过程之间有一个广阔的“灰色地带”。这里面的变化非常多，难以穷尽。这两个极端都不是我们要追求的，我们要做的是找到其中的一个平衡点。
那这个平衡点怎么找呢？根据目前国内多数人的编程习惯，在这门课程里，我们采用这样的原则：在领域对象不直接或间接访问数据库的前提下，尽量面向对象。
为了理解这句话，咱们一会儿先按面向过程的方式写出程序，然后通过重构，逐渐向面向对象靠拢。在这个过程里，咱们可以体会不同编程范式的特点，以及思考它们怎样融合。
另外，由于不能在对象之间自由导航，所以相对传统的面向对象编程来说，我们的编程风格会偏过程一些。
我还是要提醒一句，在架构师的眼里往往没有唯一正确的方法，而是要在几种不同方法中作出权衡。
“开卡”和“验卡”
好，理论就讲这么多，回到开发过程。现在咱们俩都是资深程序员，另外，还有一个领域专家和我们配合，就叫他老王。
假设距离领域建模已经过去三四天了，今天我们开始真正编写“添加组织”这个功能。但是有两个问题：第一，尽管几天前已经澄清过需求，但会不会当时有什么遗漏呢？第二，就算当时没有遗漏，那么最近几天，会不会又有些新的变化没有通知到我们呢？
所以，有必要在真正动手编码之前，找老王再次确认一下。这实际上是敏捷中的一个常用实践，叫做“开卡”。相应地，在代码开发完毕，正式提交测试之前，也会把领域专家或测试人员叫过来大体看一下有没有方向上的错误，这一步叫“验卡”。这两个实践可以有效避免因为需求理解不一致而导致的返工。
经过和老王确认，我们果然又发现了几个新的业务规则。比如，同一个组织里，不能有两个同名的下级组织。也就是说，假如“金融开发中心”下面已经有“开发一组”了，那么新加的开发组，不能也叫“开发一组”。
下面这张表，是和老王澄清需求以后整理的和“添加组织”有关的业务规则。其中绿色部分是这次新加的：

其实，和业务人员不断澄清需求，不断补充新的领域知识，正是 DDD 和敏捷软件开发的常态。
在这个表里我们发现，有一些“租户必须有效”“上级组织必须有效”这样的规则，说明在相应的实体里要增加状态属性来表达“有效”“终止”等状态。经过和老王的讨论，我们决定在租户、组织、组织类别、员工、客户、合同、项目等实体中都增加状态，并且在数据库里添加相应的字段。
DDD 强调，在代码编写阶段，如果发现模型的问题，要及时修改模型，始终保持代码和模型的一致。
面向过程的代码
需求澄清以后，我们终于可以写代码了。假如我刚学了一点 DDD 的分层架构，但是只会面向过程的方法，那么写出来大概是下面这个样子。
我们先通过包结构，看一下总体的逻辑。

这里分成了六步，我们简单解释下。
第一步，适配器层里的 OrgController 通过 Restful API 接收到添加组织的请求，请求数据封装在 OrgDto 里。
第二步，Controller 以 OrgDto 为参数，调用应用层里的 OrgService 服务中的 addOrg() 方法进行处理。
第三步，OrgService 对参数进行校验，过程中会调用适配器层里的 Repository 来访问数据库。
第四步，OrgService 创建领域层里的 Org 对象，也就是组织对象。
第五步，OrgService 调用 OrgRepository 把组织对象存到数据库，并回填组织 id。
第六步，OrgService 把组织对象装配成 DTO，返回给控制器，控制器再返回给前端。
整个过程还是比较直白的，目前主要逻辑都集中在 OrgService 里，也就是第三步到第六步。
我们再看看两个主要的数据类。一个是领域对象类 Org。
public class Org {
    private Long id;
    private Long tenantId;
    private Long superiorId;
    private String orgTypeCode;
    private Long leaderId;
    private String name;
    private OrgStatus status;          // 使用了枚举类型
    private LocalDateTime createdAt;
    private Long createdBy;
    private LocalDateTime lastUpdatedAt;
    private Long lastUpdatedBy;
    public Org() {
        status = OrgStatus.EFFECTIVE;  //组织的初始状态默认为有效
    }
    
    //getters and setters ...    
}
另一个是 OrgDto。
public class OrgDto {
    private Long id;
    private Long tenantId;
    private Long superiorId;
    private String orgTypeCode;
    private Long leaderId;
    private String name;
    private String status;
    private LocalDateTime createdAt;
    private Long createdBy;
    private LocalDateTime lastUpdatedAt;
    private Long lastUpdatedBy;
 
    // getters and setters ...
}
目前这两个类十分相似，而且都只有数据没有行为。唯一的不同是，Org 的状态属性 Status 是一个枚举类型，算是比 OrgDto 略微“面向对象”一点。
层间依赖原则和依赖倒置
现在我们从 Controller 开始逐层往下捋，下面是 Controller 的代码。
@RestController
public class OrgController {
    private final OrgService orgService;
    @Autowired
    public OrgController(OrgService orgService) {
        this.orgService = orgService;
    }
    @PostMapping("/api/organizations")
    public OrgDto addOrg(@RequestBody OrgDto request) {
        //从请求里解析出 userId ...
        return orgService.addOrg(request, userId);
    }
}
简单起见，我省略了身份认证、Http 返回码等处理。所以 addOrg 方法中只有一句，就是调用 Service。然而就是这一句，已经违反了我们上节课说的层间依赖原则。你能发现是哪里出了问题吗？
没错，由于 OrgDto 是应用服务中 addOrg 方法的入口参数类型，所以应用层是依赖 OrgDto 的，而 OrgDto 又在适配器层。也就是说，应用层依赖了适配器层。而在上节课的分层架构中，应用层在适配器层的内层，而内层是不应该依赖外层的。这样，就违反了层间依赖原则。
改起来倒是简单，只要把 OrgDto 移动到应用层就可以了，修改后是后面这样。

这里还要注意一点，手工移动类是很麻烦的。现在像 IDEA、Eclipse 这样的 IDE，都有“重构”菜单，提供了丰富的自动化重构功能，我们应该学会尽量使用。后面课程的重构我们都是尽量依靠重构菜单完成的。
看完 Controller，我们再重点看一下应用层的 OrgService，代码结构是后面这样 /
@Service
public class OrgService {
    private final UserRepository userRepository;
    private final TenantRepository tenantRepository;
    private final OrgTypeRepository orgTypeRepository;
    private final OrgRepository orgRepository;
    private final EmpRepository empRepository;
    @Autowired
    public OrgService(UserRepository userRepository
            , TenantRepository tenantRepository
            , OrgRepository orgRepository
            , EmpRepository empRepository
            , OrgTypeRepository orgTypeRepository) {
            
            //为各个Repository赋值...        
    }
    public OrgDto addOrg(OrgDto request, Long userId) {
        validate(request, userId);
        Org org = buildOrg(request, userId);
        org = orgRepository.save(org);  
        return buildOrgDto(org);
    }
    private OrgDto buildOrgDto(Org org) {
        // 将领域对象的值赋给DTO...
    }
    private Org buildOrg(OrgDto request, Long useId) {
        // 将DTO的值赋给领域对象...
    }
    private void validate(OrgDto request) {
        //进行各种业务规则的校验，会用到上面的各个Repository...  
    }
}
主控逻辑在 addOrg 方法里（19～24 行），也很简单，先校验参数，再创建领域对象，然后保存到数据库，最后返回 DTO。不过在这里，是不是又发现了一处违反层间依赖的地方呢？
可能你已经找到了，就是对仓库，也就是 Repository 的调用。根据上节课，仓库放在适配器层，而应用层调用了仓库，造成应用层对适配器层的依赖，这就再一次违反了层间依赖规则。
这时候我们该怎么办呢？像前面那样，把仓库移到应用层吗？可是仓库是适配器，就应该放在适配器层呀。这里就要用到一个技巧了，通过两步就可以解决.
第一步，从仓库抽出一个接口，原来的仓库成为了这个接口的实现类,
第二步，把这个接口移动到领域层。
修改后的结构是后面这样。

仓库接口都按照 XxxRepository 的形式命名。而仓库的实现是在接口名字的后面加上 Jdbc ，这是因为在目前的例子里只是用了 Jdbc 来做持久化。OrgService 中的代码，除了 import 语句要调整一下以外，其他都没有变化。Spring 框架会“偷偷地”把实现类注入到相关属性。
以 OrgRepository 为例，接口代码是后面这样的。
package chapter10.unjuanable.domain.orgmng; //注意：仓库的接口在领域层
//import ... 
public interface OrgRepository {
    Optional<Org> findByIdAndStatus(long tenantId, Long id
                                    , OrgStatus status);
    int countBySuperiorAndName(long tenantId, Long superiorId
                                    , String name);
    boolean existsBySuperiorAndName(Long tenant, Long superior
                                    , String name);
    Org save(Org org);
}
而实现类仍然在适配器层，像后面这样。
//注意：Repository 的实现类在适配器层
package chapter10.unjuanable.adapter.driven.persistence.orgmng;
//import ...
@Repository
public class OrgRepositoryJdbc implements OrgRepository {
    JdbcTemplate jdbc;
    SimpleJdbcInsert insertOrg;
    @Autowired
    public OrgRepositoryJdbc(JdbcTemplate jdbc) {
        //...
    }
    @Override
    public Optional<Org> findByIdAndStatus(Long tenantId, Long id, OrgStatus status) {
        //...        
    }
    @Override
    public int countBySuperiorAndName(Long tenantId, Long superiorId, String name) {
        //...
    }
    @Override
    public boolean existsBySuperiorAndName(Long tenant, Long superior, String name) {
        //...
    }
    
    @Override
    public Org save(Org org) {
        //...
    } 
}
为什么这样做就解决了层间依赖呢？让我们画一个 UML 图来更直观地看一下。

这是和程序结构等价的 UML 图。不过要注意，我们现在画的是设计模型的类图，和前面领域建模的类图会有一些区别。
首先，在设计图里用的是英文，而领域模型图里用了中文。这是因为用中文更容易和领域专家交流，而设计图是给程序员看的，用英文更贴近代码。中英文的转换则依照词汇表。
第二个区别是，这个图里画的都不是领域对象，而是用来实现程序的对象。当然，设计图里也可以画领域对象，只不过针对目前这个问题，我们把领域对象省略了。但是反过来，领域模型图中一定不能存在只有技术人员才懂的内容。
现在我们看一下从 OrgService 到领域层中仓库接口的三个箭头。它们实际上代表了 OrgService 中用这三个接口定义的属性。这些箭头也是关联关系，只不过是技术意义上的。由于 OrgService 可以通过属性导航到仓库，而仓库中并没有属性能够导航到 OrgService，所以关联是单向的。关联也是一种依赖关系，所以可以说 OrgServie 依赖仓库，说明应用层依赖领域层。
再看从仓库实现类指向接口的带虚线的空三角箭头。这个符号表示类对接口的实现关系，在领域模型中一般是不使用的。实现关系也是一种依赖，所以现在适配器层也依赖了领域层。
看见没有？原来应用层对适配器层的依赖神奇地消失了，取而代之的是应用层和适配器层两者对领域层的依赖。层间依赖的问题就解决了。
原来是别的层依赖适配器，现在通过抽取和移动接口，变成了适配器依赖别的层，依赖关系被“倒过来”了。所以这种技巧就称为依赖倒置（dependency inversion），是面向对象设计中常见的调整依赖关系的手段。
最后还有一个问题，为什么要把仓库接口移动到领域层而不是应用层呢？移到应用层不是也可以解决这个问题吗？
不错，就目前而言，移动到应用层也可以。但是后面我们会看到，领域层中的代码也有可能访问数据库。所以要移动到领域层，否则会出现新的层间依赖问题。
总结
好，今天的内容先讲到这里，我们来总结一下。
这节课我们开始编写代码，要实现两个要求：一个是保持代码和模型一致；另一个是符合通用的编程原则和最佳实践。
我们讨论了“贫血模型”“充血模型”“面向对象”和“面向过程”几个概念的关系。这里我们要清楚，在实践中，面向对象和面向过程往往不是非黑即白的，传统意义上纯粹的面向对象编程在企业应用中未必适合，应该把多种编程范式结合起来。
我们还讲了敏捷中“开卡”和“验卡”两个实践，补充了业务规则。这里我想再次强调，编写代码的时候如果发现模型的问题，要及时修改模型，始终保持代码和模型的一致。
在代码层面，今天的重点是解决层间依赖问题。我们做了两个改进：一是把 DTO 从适配器层移到了应用层；另一个是采用“依赖倒置”原则，使适配器层依赖于领域层。
在解释依赖倒置时，我们还用到了设计层面的 UML 图，希望你能借此理解领域模型和设计模型的区别。理解这种区别有两方面的好处，一个是在沟通过程中，知道哪些应该和业务人员讨论，哪些应该只在程序员内部讨论；另一个是区分不同的抽象层次，使我们思考问题的能够更加聚焦和高效。
思考题
1. 在你的心目中，面向对象有哪些特征？假如用偏过程的方式，是否也能实现这些特征？
2. 在今天的程序中，领域逻辑主要体现在哪段代码，它们放对地方了吗？
好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们继续优化程序，达到 DDD 的要求，并且更加“面向对象”一点。
